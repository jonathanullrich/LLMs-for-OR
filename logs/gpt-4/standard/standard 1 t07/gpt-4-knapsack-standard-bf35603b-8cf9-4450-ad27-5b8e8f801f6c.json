{
    "system_prompt": "You are an operations research expert. Write python code to solve the given problem. Assign the final output to a variable 'solution'. Only assign one number.",
    "problem_description": "Consider the following problem: A hiker has a 5-ft^3 backpack and needs to decide on the most valuable items to take on the hiking trip. There are three items from which to choose. Their volumes are 2, 3, and 4 ft^3, and the hiker estimates their associated values on a scale from 0 to 100 as 30, 50, and 70, respectively. Find the optimal solution.",
    "output": "This problem can be solved using dynamic programming. Here is a Python code to solve this problem:\n\n```python\ndef knapSack(W, wt, val, n):\n    K = [[0 for w in range(W + 1)]\n            for i in range(n + 1)]\n             \n    # Build table K[][] in bottom\n    # up manner\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            elif wt[i - 1] <= w:\n                K[i][w] = max(val[i - 1]\n                  + K[i - 1][w - wt[i - 1]],\n                               K[i - 1][w])\n            else:\n                K[i][w] = K[i - 1][w]\n \n    return K[n][W]\n     \n# Driver code\nval = [30, 50, 70]\nwt = [2, 3, 4]\nW = 5\nn = len(val)\n     \n# This code is contributed by Bhavya Jain\nsolution = knapSack(W, wt, val, n)\n```\n\nThis code uses a dynamic programming approach to solve the 0-1 Knapsack problem, where we have a knapsack of capacity W and we want to maximize the total value of items we can put into the knapsack. The items have weights wt[] and values val[], and we can only put an item in the knapsack once (0-1 property). \n\nIn the knapSack function, we create a 2D table K[][] where K[i][w] will store the maximum value that can be achieved with a knapsack of capacity w using the first i items. We then fill up this table in a bottom-up manner. We start by filling the first row and the first column with zeroes, since they represent the case where we have 0 items or a knapsack with capacity 0. \n\nThe rest of the cells are filled by considering the i-th item: if it can fit into the knapsack (i.e. its weight is less than or equal to the current capacity), we take the maximum of two options - either including this item in the knapsack or not including it. If it can't fit, we simply don't include it. The maximum value that can be achieved is stored in K[n][W] at the end, which we return as the solution.\n\nIn the driver code, we define the values and weights of the items and the capacity of the knapsack, and call the knapSack function to get the solution.",
    "code": "def knapSack(W, wt, val, n):\n    K = [[0 for w in range(W + 1)]\n            for i in range(n + 1)]\n             \n    # Build table K[][] in bottom\n    # up manner\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            elif wt[i - 1] <= w:\n                K[i][w] = max(val[i - 1]\n                  + K[i - 1][w - wt[i - 1]],\n                               K[i - 1][w])\n            else:\n                K[i][w] = K[i - 1][w]\n \n    return K[n][W]\n     \n# Driver code\nval = [30, 50, 70]\nwt = [2, 3, 4]\nW = 5\nn = len(val)\n     \n# This code is contributed by Bhavya Jain\nsolution = knapSack(W, wt, val, n)",
    "solution": 80
}